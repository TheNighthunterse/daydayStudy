### Map

**Map 是一个真正的键值对集合**,虽然 Object 也能存键值对，但 Object 的初衷是作为“记录（Record）”或“实体”的容器（比如 `{ name: 'Alice' }`），而 Map 才是专为“高频查找、增删”而生的**哈希表（Hash Map）数据结构**。

简单来说，**Object更适合稳定的结构，Map则适用于操作频繁的对象**

------

#### Map 的核心属性与常用操作

Map 的 API 设计得非常人性化，完全是函数式的：

- **`size`**：这是一个属性，直接返回成员总数。*（Object 需要用 `Object.keys().length`，还得遍历一遍，复杂度 $O(n)$）*。
- **`set(key, value)`**：设置键值对，返回 Map 本身（支持链式调用）。
- **`get(key)`**：读取键。如果找不到，返回 `undefined`。
- **`has(key)`**：检查键是否存在。
- **`delete(key)`**：删除某个键。
- **`clear()`**：清空所有成员。

------

####  Map 解决了 Object 的哪些“痛点”

对于成熟开发者来说，下面这四点是选择 Map 的核心理由：

① 键的类型无限制（核心优势）

- **Object**：键必须是 **String** 或 **Symbol**。如果你用一个对象当键，它会自动调用 `.toString()` 把它变成 `"[object Object]"`，这会导致覆盖。

- **Map**：**任何值**都可以是键。包括函数、对象、甚至 `NaN`。

  > **Vue 3 场景**：Vue 3 需要把一个“原始对象”作为键来查找它的依赖图。这时候只有 Map（和 WeakMap）能胜任。

② 保证插入顺序

- **Object**：属性的遍历顺序非常复杂（受整数索引、插入时间、Symbol 的影响）。
- **Map**：严格按照**插入顺序**进行遍历。

③ 内置可迭代接口

- **Object**：不能直接用 `for...of` 遍历，得先转成数组。
- **Map**：原生支持 `for...of`，支持 `.forEach()`。

④ 性能更优

- 在涉及**频繁增删**键值对的场景下，Map 的底层优化使得它的性能通常优于 Object。

| **维度**     | **Object**                              | **Map**                      |
| ------------ | --------------------------------------- | ---------------------------- |
| **键的类型** | String / Symbol                         | **任意类型**                 |
| **键的顺序** | 混乱（不保证顺序）                      | **有序**（按插入顺序）       |
| **大小获取** | 麻烦 (`Object.keys().length`)           | 简单 (`.size`)               |
| **迭代性**   | 不支持迭代协议                          | **支持迭代**                 |
| **性能**     | 适合少量数据、结构稳定的配置            | **频繁增删、大量数据**查找   |
| **原型干扰** | 有原型链（`toString` 等），容易产生冲突 | **纯净**，只存你放进去的数据 |

------

#### Map的缺点

虽然 Map 强大，但它不是要完全替代 Object：

1. **JSON 传输**：Map 不能直接序列化为 JSON，需要手动转换。而 Object 原生支持。
2. **简单的记录结构**：如果你只是想存一个组件的配置或者用户信息，用 Object 更轻量，内存占用也更低。
3. **逻辑绑定**：如果你需要使用 `this` 在属性间互相调用，Map 存的只是纯粹的数据映射，不适合做面向对象的封装。

------

### Set

Set 是 ES6 新增的一种**集合**数据结构。它类似于数组，但核心区别在于：**它的成员的值都是唯一的，没有重复的值。**

#### 常用操作（API）

Set 的 API 非常干练，主要围绕“增删查”：

- **`add(value)`**：添加某个值，返回 Set 本身（支持链式调用）。如果值已存在，则静默失败（不报错，也不重复添加）。
- **`delete(value)`**：删除某个值，返回一个布尔值，表示是否删除成功。
- **`has(value)`**：返回布尔值，判断该值是否为 Set 的成员。
- **`clear()`**：清除所有成员。
- **`size`**：返回成员总数。

------

#### 优点

##### 性能：从 O(n) 到 O(1)

- **Array**: 判断一个元素是否存在（`includes` / `indexOf`），需要遍历数组，时间复杂度是 **$O(n)$**。
- **Set**: 内部基于哈希表实现，判断是否存在（`has`）的时间复杂度是 **$O(1)$**。
- **Vue 场景**：一个属性可能会被同一个 `effect` 读取多次。如果不去重，每次读取都推入依赖数组，数据更新时就会触发大量冗余更新。使用 Set，重复添加同一个 `effect` 是瞬间被拦截且无感的。

#####  逻辑纯净：天然去重

在处理数据集合时，Set 让你不再需要手动写复杂的循环去重代码

------

| **维度**       | **Array**                        | **Set**                              |
| -------------- | -------------------------------- | ------------------------------------ |
| **元素重复**   | 允许重复                         | **严格唯一**                         |
| **查找效率**   | 低 (*O(n)*)                      | **高 (*O(1)*)**                      |
| **顺序与索引** | 有索引，通过 `arr[i]` 访问       | 无索引，不能通过下标访问             |
| **插入效率**   | 尾部插入快，中间插入慢           | **极快**                             |
| **应用场景**   | 排序、堆栈、需要按顺序索引的列表 | **去重、判断成员是否存在、集合运算** |

------

#### 进阶用法：集合运算

Set 还有一些“骚操作”，能让你优雅地处理数组关系：

- **数组去重**：`[...new Set(array)]`（目前 JS 最简洁的去重方式）。
- **交集**：`new Set([...set1].filter(x => set2.has(x)))`。
- **差集**：`new Set([...set1].filter(x => !set2.has(x)))`。