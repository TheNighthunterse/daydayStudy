### 异步与事件循环

异步（Asynchronous）和事件循环（Event Loop）是现代编程——尤其是 JavaScript 和后端高并发服务——的核心灵魂

#### **为什么需要它？**

计算机的 CPU 运算速度极快，但 **I/O 操作**（读写文件、网络请求、数据库查询）慢得像蜗牛。如果同步执行，CPU 绝大部分时间都在“等”数据返回，这简直是极大的浪费

------

#### **事件循环 (Event Loop) 的运行机制**

1. **调用栈 (Call Stack)**：代码运行的地方。如果栈里有任务，就先执行。
2. **任务队列 (Task Queue)**：当异步操作（如 `setTimeout` 或网络请求）完成时，它们不会立刻执行，而是把回调函数扔进队列里排队
3. **循环检查**：事件循环会不断监视：**“调用栈空了吗？”** 如果空了，它就会从队列里抓出第一个任务，推入栈中执行

**重点提示**：在 JavaScript 中，异步任务还分“微任务”（Microtask，如 Promise）和“宏任务”（Macrotask，如 setTimeout）。**微任务总是插队在宏任务之前执行**

------

#### **优秀的机制**

- **非阻塞**：一个网络请求卡住了，网页不会因此“未响应”，你还能继续点击按钮
- **单线程也高效**：JavaScript 虽是单线程，但通过事件循环，它能处理数以万计的并发连接（这也是 Node.js 擅长高并发的原因）。

------

#### 进化史：从回调地狱到优雅代码

| **阶段**        | **形式**          | **痛点**                                            |
| --------------- | ----------------- | --------------------------------------------------- |
| **回调函数**    | `getData(fn)`     | 回调地狱（Callback Hell），代码像个横过来的金字塔。 |
| **Promise**     | `.then().catch()` | 链式调用好多了，但嵌套多起来依然眼花缭乱。          |
| **Async/Await** | `await getData()` | **终极方案**。代码读起来和同步一模一样，极其优雅。  |

### **底层逻辑**和**架构设计**

要深度理解异步与事件循环，必须跳出 JavaScript 的语法表面，去拆解 **宿主环境（浏览器/Node.js）** 与 **操作系统内核** 之间的协作机制

------

#### 宏观视角：单线程为何能处理多线程的任务？

JavaScript 确实是单线程的，但**执行环境（Runtime）**是多线程的

当你发起一个异步请求时，JavaScript 调用栈（Call Stack）只是下达了一个指令，真正的苦力活是由宿主环境的**工作线程（Worker Threads）**完成的

- **网络请求**：由浏览器的网络模块（Network Thread）负责
- **定时器**：由定时器触发线程（Timer Thread）计时
- **DOM 事件**：由浏览器事件触发线程监听

**深度思考**：异步的本质不是“并行执行代码”，而是**“利用多线程 I/O 隐藏等待延迟”**。当这些后台线程完成任务后，它们会将回调包装成任务，塞进任务队列，等待 JS 主线程垂幸

------

#### 微观视角：任务队列的“优先级森严”

并不是所有异步任务都平等。在一次事件循环（Tick）中，存在一个精细的控制流。

##### 宏任务(Macrotask)vs 微任务(Microtask)

- **宏任务**：代表一个离散的工作单元（setTimeout, setInterval, I/O, UI 渲染）。
- **微任务**：代表“在当前任务之后立即执行的事”（Promise.then, MutationObserver, Node.js 的 process.nextTick）。

##### 循环的核心算法（Event Loop Tick）：

1. 从**宏任务队列**中取出一个最旧的任务执行。
2. **关键步骤**：检查**微任务队列**。只要微任务队列不为空，就一直取出并执行，直到清空（即使在执行过程中又产生了新的微任务，也会在当前 Tick 内一并扫光）。
3. **更新渲染**：检查是否需要重绘 UI（仅限浏览器）。
4. 开始下一次 Tick，回到步骤 1。

> **深度洞察**：为什么 Promise 比 setTimeout 快？因为 Promise 是微任务，它在当前宏任务执行完后**立即**清理；而 setTimeout 必须等到下一次循环。

------

#### 哲学思考：为什么是单线程？

**因为“状态一致性”的成本太高。** 多线程意味着你需要处理**死锁（Deadlock）**、**竞态条件（Race Condition）**和**内存同步**。JavaScript 选择“单线程 + 事件循环”，是用一种相对简单的编程模型，解决极其复杂的并发问题。它保证了你在处理数据时，不用担心别的线程偷偷改了你的变量

#### 手写一个简易的 Event Loop 模拟器

##### 模拟器核心代码

```javascript
class SimpleEventLoop {
  constructor() {
    this.callStack = [];         // 调用栈
    this.microtaskQueue = [];    // 微任务队列 (Promise等)
    this.macrotaskQueue = [];    // 宏任务队列 (setTimeout等)
    this.isLooping = false;
  }

  // 模拟全局代码执行（第一个宏任务）
  executeScript(scriptFn) {
    console.log("--- 脚本开始执行 ---");
    scriptFn();
    this.runLoop();
  }

  // 添加宏任务
  addMacrotask(task) {
    this.macrotaskQueue.push(task);
  }

  // 添加微任务
  addMicrotask(task) {
    this.microtaskQueue.push(task);
  }

  // 核心循环逻辑
  async runLoop() {
    this.isLooping = true;

    while (this.macrotaskQueue.length > 0 || this.microtaskQueue.length > 0) {
      
      // 1. 执行所有的微任务 (Microtask Cleanup)
      // 注意：微任务执行过程中新产生的微任务，也会在本次清空
      while (this.microtaskQueue.length > 0) {
        const microtask = this.microtaskQueue.shift();
        console.log("[执行微任务]");
        microtask();
      }

      // 2. 执行一个宏任务 (Macrotask)
      if (this.macrotaskQueue.length > 0) {
        const macrotask = this.macrotaskQueue.shift();
        console.log("\n--- 新的 Tick ---");
        console.log("[执行宏任务]");
        macrotask();
      }

      // 模拟循环间隙，防止死循环阻塞环境
      await new Promise(resolve => setTimeout(resolve, 0));
    }

    console.log("\n--- 所有任务处理完毕，进入休眠 ---");
    this.isLooping = false;
  }
}
```

##### 模拟真实场景测试

```javascript
const loop = new SimpleEventLoop();

loop.executeScript(() => {
  console.log("1. 同步代码执行");

  // 模拟 setTimeout (宏任务)
  loop.addMacrotask(() => {
    console.log("2. setTimeout 回调");
    loop.addMicrotask(() => console.log("3. setTimeout 里的微任务"));
  });

  // 模拟 Promise.then (微任务)
  loop.addMicrotask(() => {
    console.log("4. 第一个 Promise 回调");
    loop.addMicrotask(() => console.log("5. 嵌套的微任务"));
  });

  console.log("6. 同步代码结束");
});
```

##### 预期输出顺序及深度解析：

1. **1. 同步代码执行** & **6. 同步代码结束**：直接入栈执行。
2. **4. 第一个 Promise 回调**：第一个宏任务（脚本本身）完成后，立即检查微任务队列。
3. **5. 嵌套的微任务**：微任务清空过程中发现新任务，继续清空。
4. **2 setTimeout 回调**：开启下一个 Tick，取出宏任务队列第一个。
5. **3. setTimeout 里的微任务**：该宏任务执行完，再次清空微任务队列。

通过手写模拟器，可以洞察到三个关键点：

- **任务的“原子性”**

  一旦一个任务（无论是宏任务还是微任务）被推入 **Call Stack**，它必须执行到完（Return），中途不会被切换。这就是为什么主线程耗时计算会卡死 UI。

- **微任务的“激进性”**

  在模拟器的 `while (microtaskQueue.length > 0)` 中你可以看到，微任务是**贪婪**的。只要有，就执行完。这解释了为什么在高频触发的异步任务中（如 `process.nextTick`），微任务可能导致宏任务（如 I/O）**饥饿（Starvation）**

- **渲染的时机**

  虽然代码里没写，但在浏览器规范中，**Rendering（渲染更新）** 发生在“微任务队列清空后”与“下一个宏任务开始前”

**深度结论**：如果你想在代码中做多次 DOM 操作并希望浏览器只渲染一次，你应该把它们放在同一个宏任务或微任务序列中。如果你想让浏览器在两次操作间喘息并渲染，你需要用 `setTimeout` 把任务分割

##### JavaScript 引擎处理代码的**真实分层模型**

1. **脚本即是“第一个宏任务”**

   整个 JS 文件的执行（也就是你说的“进店下单”）在规范中被称为 **Initial Script**

   - 事件循环启动后的**第一个动作**，就是把这整个脚本作为一个宏任务（Macrotask）扔进执行栈
   - 所以，所有的同步代码其实都是在“第一个宏任务”里运行的

2. **“清空”的逻辑：宏任务与微任务的套娃**

   **微任务不是独立存在的，它必须依附于某个宏任务**

   每一个宏任务执行完（或者是同步脚本执行完）之后，引擎都会问一句：“刚才这个过程中，有没有攒下的微任务？”

   - 如果有，**哪怕有 100 个**，也要在这个宏任务结束前全部干掉
   - 只有微任务队列彻底清空了，引擎才会去瞅一眼“下一个宏任务”

3.  为什么这个理解很重要？（进阶思考）

   1. Vue/React 的异步更新

      当你修改了 10 次数据，Vue 不会渲染 10 次。它会把“修改 DOM”这个动作包在一个微任务里（通过 `nextTick`）

      - **底层逻辑**：数据改变（宏任务进行中） -> 产生微任务 -> 脚本运行结束 -> **执行微任务（统一更新 DOM）** -> 浏览器渲染
      - **好处**：保证了性能，避免了频繁的页面抖动

   2. 微任务的“死循环”

      如果在微任务里又生成了一个微任务，会发生什么？

      - **答案**：下一个宏任务（比如鼠标点击、定时器、页面滚动）永远得不到执行
      - **原因**：必须等当前宏任务里的微任务**全部**执行完。如果微任务源源不断，事件循环就卡死在这个“清理阶段”了

------

##### 公式

> 1个宏任务 + 该任务产生的所有微任务 = 1个完整的事件循环周期(Tick)