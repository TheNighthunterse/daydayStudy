### 题一

```javascript
async function async1() {
  console.log('1. async1 start');
  await async2();
  console.log('2. async1 end');
}

async function async2() {
  console.log('3. async2');
}

console.log('4. script start');

setTimeout(function() {
  console.log('5. setTimeout');
}, 0);

async1();

new Promise(function(resolve) {
  console.log('6. promise1');
  resolve();
}).then(function() {
  console.log('7. promise2');
});

console.log('8. script end');
```

避坑提示（在给出答案前，先看这两个关键点）：

1. **`await` 到底是什么？** 当代码运行到 `await async2()` 时，它会**立即执行** `async2()` 函数体内的代码，但 `await` **之后**的代码（即 `console.log('2. async1 end')`）会被立刻打包成一个**微任务**，丢进微任务队列。你可以把它理解为 `Promise.then` 的语法糖。
2. **`Promise` 构造函数是同步的：** `new Promise((resolve) => { ... })` 括号里的代码是**立即执行**的，只有 `.then()` 里的回调才是微任务。
3. 如果答案里面`2`出现在`6`和`8`前面。这说明你的大脑在运行代码时，把 `await` 之后的代码当成了**同步执行**，或者说你给它的优先级太高了

#### 答案与深度解析

**`4. script start`**：同步代码，第一个宏任务开始。

**`1. async1 start`**：调用 `async1`，同步执行。

**`3. async2`**：`await` 后面的函数立即执行。

**`6. promise1`**：`new Promise` 内部是同步的。

**`8. script end`**：同步脚本执行完毕。

- *此时，第一个宏任务（Script）结束，引擎开始清空微任务队列。*

**`2. async1 end`**：`await` 产生的微任务排在前面。

**`7. promise2`**：`Promise.then` 产生的微任务。

- *此时，微任务队列清空，进入下一个 Tick，执行传菜口的宏任务。*

**`5. setTimeout`**：最后执行宏任务。

#### `await` 的“暂停”艺术

记住这个公式：

​	`await` 之下的代码 = `Promise.then()` 里的回调 = 微任务

再看看这段代码

```javascript
async function async1() {
  console.log('1. async1 start'); 
  await async2(); // <--- 关键点！
  console.log('2. async1 end'); // 这句被“推迟”了
}
```

当JS 引擎执行到这一步时：

1. **立即执行** `async2()` 里的代码（打印 `3. async2`）。
2. 看到 `await`，大厨会说：“OK，`async2` 后面的活（打印 `2. async1 end`）我先记在**微任务小本本**上。现在，我要**跳出这个函数**，去执行主脚本里剩下的同步代码。”
3. **这就是为什么 `6` 和 `8` 会抢在 `2` 前面。** 因为 `6` 和 `8` 还在当前的同步任务（第一个大宏任务）里，而 `2` 已经在排队等微任务清理了。

**为什么会觉得 `2` 应该在前面？**

**错误思想**：“既然 `async2` 已经执行完了，那 `2` 不就应该接着执行吗？”

其实，这就是异步编程设计的初衷：**给其他同步代码“让路”**。即使 `async2` 瞬间执行完，`await` 也会强制把后续代码转为异步微任务。这保证了哪怕某个异步操作极快，它也不会打断当前正在运行的同步逻辑流

### 题二

```javascript
console.log('1. script start');

setTimeout(() => {
  console.log('2. setTimeout');
}, 0);

async function async1() {
  console.log('3. async1 start');
  await async2();
  console.log('4. async1 end');
}

async function async2() {
  console.log('5. async2');
}

async1();

new Promise((resolve) => {
  console.log('6. promise start');
  resolve();
}).then(() => {
  console.log('7. promise then1');
}).then(() => {
  console.log('8. promise then2');
});

console.log('9. script end');
```

这里的“深层陷阱”：

1. **多次 `.then()`**：当第一个 `.then()` 执行完后，第二个 `.then()` 才会进入微任务队列。它们不是同时进去排队的。
2. **`await` 的连续性**：请再次运用你的“后厨模型”，把 `await` 之后的所有逻辑打包成一个整体。

#### 答案公布与深度拆解：

1. **`1. script start`** (同步)
2. **`3. async1 start`** (同步，进入函数)
3. **`5. async2`** (同步，await 立即执行其后的函数)
   - *此时：`4. async1 end` 被封进微任务容器（记为 **M1**）*
4. **`6. promise start`** (同步，Promise 构造函数立即执行)
   - *此时：`7. promise then1` 进入微任务队列（记为 **M2**）*
5. **`9. script end`** (同步)
   - *主线程空了！开始按顺序清空微任务队列 [M1, M2]*
6. **`4. async1 end`** (执行 M1)
7. **`7. promise then1`** (执行 M2)
   - *注意！M2 执行完，触发了 `8. promise then2` 进入队列（记为 **M3**）*
8. **`8. promise then2`** (执行 M3，微任务队列清空)
9. **`2. setTimeout`** (进入下一个宏任务 Tick)

### 题三

```javascript
setTimeout(() => {
  console.log('1. macro-1 (setTimeout)');
  Promise.resolve().then(() => {
    console.log('2. micro-in-macro');
  });
}, 0);

async function demo() {
  console.log('3. async start');
  await Promise.resolve();
  console.log('4. async micro');
  
  setTimeout(() => {
    console.log('5. macro-2 (setTimeout in async)');
  }, 0);
}

demo();
console.log('6. script end');
```

#### 拆解这个“套娃”：

第一阶段：同步脚本（第一个宏任务）

1. **`setTimeout-1`** 注册。服务员开始计时（0ms），完成后把回调 `1` 扔进宏任务队列。
2. 执行 `demo()`，打印 **`3. async start`**。
3. 碰到 `await`，把剩下的代码（打印 `4` 和注册 `setTimeout-2`）打包成微任务 **M1**。
4. 打印 **`6. script end`**。

第二阶段：清理微任务（当前 Tick 结束前）

1. 大厨取出 **M1**：
   - 打印 **`4. async micro`**。
   - **注册 `setTimeout-2`**。服务员计时（0ms），完成后把回调 `5` 扔进宏任务队列。
   - *注意：此时宏任务队列里有两个：[`setTimeout-1`, `setTimeout-2`]*

第三阶段：下一个宏任务 Tick（处理 setTimeout-1）

1. 大厨从宏任务队列取出 `setTimeout-1`。
2. 打印 **`1. macro-1`**。
3. **发现微任务**：`.then()` 把打印 `2` 丢进微任务队列。
4. **重要！** 当前宏任务结束，大厨**必须先清空**微任务队列。
5. 打印 **`2. micro-in-macro`**。

第四阶段：再下一个宏任务 Tick（处理 setTimeout-2）

1. 大厨取出 `setTimeout-2`。
2. 打印 **`5. macro-2`**。

### 题四

```javascript
function getJson() {
    return new Promise(function (resolve, reject) {
        setTimeout(() => {
            console.log(2);
            resolve(2)
        }, 2000)
    })
}

async function testAsync() {
    await getJson()
    console.log(3);
}

testAsync()
```

#### 答案

2，3

#### 深度拆解

第一阶段：同步脚本（主订单）

- 调用 `testAsync()`。
- 进入 `testAsync` 内部，遇到 `await getJson()`。
- **关键点**：大厨立即执行 `getJson()`。
  - `getJson` 返回了一个 `Promise`。
  - **但是**，这个 Promise 内部启动了一个 `setTimeout`（2秒后）。
  - 此时，这个 Promise 的状态是 **Pending（等待中）**。
- 因为 `await` 必须等待这个 Promise 变成 **Resolved（完成）**，所以 `console.log(3)` 被打包成微任务，**但现在还不能进队排队**，它在“等待室”坐着呢。
- 主脚本执行完毕。

第二阶段：漫长的 2000 毫秒（等待）

- 此时调用栈（Call Stack）是空的，微任务队列也是空的。大厨在休息。
- 服务员（Timer Thread）盯着表。

第三阶段：定时器触发（宏任务）

1. 2秒到了，服务员把 `setTimeout` 的回调扔进**宏任务队列**。
2. 大厨取出这个宏任务，开始执行：
   - 打印 **`2`**。
   - 执行 `resolve(2)`。**这一步极其关键！**
3. `resolve()` 一执行，刚才那个 Pending 的 Promise 终于变成了 **Resolved**。
4. **连锁反应**：坐了2秒“等待室”的 `console.log(3)` 终于有资格进入**微任务队列**了。

第四阶段：清空微任务

1. 大厨干完当前的宏任务（打印了2），发现案板上（微任务队列）多了一个活：打印 `3`。
2. 打印 **`3`**。

#### 误区

`await` 并不是等 `getJson` 这个函数跑完，而是等它返回的那个 **Promise 变为 resolve 状态**，微任务确实比**下一个**宏任务快，但它必须先被“触发”出来。在这个例子里，微任务是被一个宏任务（setTimeout）给“生”出来的

#### 延伸

```javascript
async function testAsync() {
    await setTimeout(() => console.log(2), 2000); // 注意这里没有 Promise
    console.log(3);
}
//结果：先打印3，两秒后打印2
```

在 JavaScript 中，**`await` 后面跟着一个“非 Promise”值（比如 `setTimeout` 的返回值）和跟着一个“未 resolve 的 Promise”，行为截然不同。**

##### `await` 后面到底是什么？

`setTimeout` 本身是一个同步函数，它的作用是“向浏览器/Node.js 申请一个定时任务”。**它返回的是一个数字（Timer ID，比如 `1`）**，而不是一个 Promise

所以这段代码可以被等同于：

```javascript
async function testAsync() {
    const timerId = setTimeout(() => console.log(2), 2000); 
    await timerId; // 相当于 await 1
    console.log(3);
}
```

##### `await` 的“包装”机制

**在ES当中**，如果`await`后面是一个`promise`就等他状态改变，如果不是则把他看做`await Promise.resolve(x)`

这就是为什么在开发中，如果你想让代码真的“睡 2 秒”，你**必须**手动用 Promise 包装一下 `setTimeout`（也就是所谓的 Promisify）

**只要`await`后面不是跟着`promise`函数都能够直接执行（下一次微任务），即使后方返回了null、undefined，因为他实际上代表`Promise.resolve(x)`，所以无论如何都不会影响执行**

##### 如果 `resolve` 了两次会发生什么

在 Promise 的世界里，有一个被称为 **“状态不可逆”** 的铁律。简单来说：**Promise 是个“一锤子买卖”，一旦尘埃落定，谁也别想改它的心**

> **结论：第一次赢，第二次输**

如果一个 Promise 内部执行了两次 `resolve`（或者先执行了 `resolve` 又执行了 `reject`），**只有第一次调用会生效**。第二次及以后的调用会被引擎直接**无视**。

Promise 的内部就像一个带锁的开关，它有三个状态：`pending`（进行中）、`fulfilled`（已成功）、`rejected`（已失败）。

- 初始状态是 `pending`。
- 一旦执行了 `resolve`，它就像从悬崖跳下，状态瞬间变为 `fulfilled`。
- **锁定机制**：一旦状态从 `pending` 切换到了其他状态，这个 Promise 就会被**锁定（Locked）**。后续任何试图改变状态的指令（再次 `resolve` 或 `reject`）都会失效

这种设计大大降低了异步编程的**复杂性**

在传统的“回调函数”时代，如果一个异步任务因为 Bug 触发了两次回调，你的业务逻辑可能会运行两遍（比如给用户充了两遍钱）。 而 **Promise 保证了你的异步逻辑（`.then` 里的内容）在整个生命周期内只会被触发一次**。这种稳定性是现代前端框架（如 React/Vue）能够可靠运行的基石

### 题五

```javascript
async function async1() {
    console.log('1. async1 start');
    await async2();
    console.log('2. async1 end');
  }

  async function async2() {
    return new Promise((resolve) => {
      setTimeout(() => {
        console.log('3. async2 (in timeout)');
        resolve();
      }, 0);
    });
  }

  console.log('4. script start');

  setTimeout(function () {
    console.log('5. setTimeout');
  }, 0);

  async1();

  new Promise(function (resolve) {
    console.log('6. promise1');
    resolve();
  }).then(function () {
    console.log('7. promise2');
  });

  console.log('8. script end');
```

#### 深度推导执行顺序

1. **同步阶段**：
   - 打印 `4. script start`。
   - 执行 `async1` --> 打印 `1. async1 start`。
   - 调用 `async2` --> **注册了一个新的定时器**（暂记为 T2），返回 Pending Promise。
   - `async1` 被挂起，`2. async1 end` 进入等待区。
   - 打印 `6. promise1`。
   - 打印 `8. script end`。
2. **微任务清理阶段**：
   - 打印 `7. promise2`（这是目前唯一在队列里的微任务）。
3. **宏任务阶段（第一轮 Tick）**：
   - 取出第一个定时器（原题里的 `5`）。
   - 打印 **`5. setTimeout`**。
4. **宏任务阶段（第二轮 Tick）**：
   - 取出 `async2` 里的定时器 T2。
   - 打印 **`3. async2 (in timeout)`**。
   - **重点来了**：调用 `resolve()`！
   - 此时，`2. async1 end` 终于重获自由，被扔进**微任务队列**。
5. **微任务清理（紧随 T2 宏任务之后）**：
   - 打印 **`2. async1 end`**。