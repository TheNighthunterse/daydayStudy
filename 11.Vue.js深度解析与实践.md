### Vue 深度解析与底层运行机制

#### 一、 Vue 运行核心三支柱

Vue 的高效运行依赖于以下三个系统的协同工作：

1. **响应式系统 (Reactivity)**：通过 `Proxy` (V3) 或 `Object.defineProperty` (V2) 拦截数据操作，实现“数据驱动视图”。
2. **编译器 (Compiler)**：将模板字符串解析为优化的 `Render` 函数。Vue 3 引入了 **Patch Flags（静态标记）** 和 **Static Hoisting（静态提升）**，实现了靶向更新。
3. **渲染器 (Renderer)**：负责将 VNode 渲染为真实 DOM。核心是 **Diff 算法**（Vue 2 双端对比 vs Vue 3 快速 Diff + LIS 最长递增子序列）。

------

#### 二、 响应式系统的进化：Vue 2 vs. Vue 3

##### 1. Vue 2：基于 `Object.defineProperty`

- **机制**：在初始化时递归遍历 `data`，利用闭包私藏变量。
- **痛点**：
  - **性能瓶颈**：初始化需全量递归，数据量大时白屏时间长。
  - **动态性缺失**：无法检测对象属性的新增和删除（需借力 `this.$set`）。
  - **数组局限**：无法拦截索引赋值（`arr[0] = x`）和 `length` 修改。
- **数组检测避坑**：Vue 2 通过**原型拦截**（重写 `push`, `pop`, `shift`, `unshift`, `splice`, `sort`, `reverse` 7个方法）来实现数组响应式。s

##### 2. Vue 3：基于 `Proxy`

- **机制**：拦截对象的“动作”而非“属性”。采用**惰性代理**，只有访问到深层属性时才触发下一层 Proxy 包装。
- **优势**：
  - **全方位监听**：原生支持属性增删、数组索引、Map/Set 集合。
  - **性能卓越**：减少了初始化开销，内存占用更低。
  - **解耦设计**：依赖关系存储在外部的 `targetMap` (WeakMap) 中，不污染原始对象。

------

#### 三、 Vue 3 底层元编程工具箱

##### 1. 存储结构：Map, Set & WeakMap

- **`WeakMap` (根容器)**：存储 `target -> depsMap`。
  - *深度理解*：使用**弱引用**，当原始对象销毁时，依赖关系自动被 GC 回收，防止内存泄漏。
- **`Map` (属性映射)**：存储 `key -> dep`。
  - *优势*：键可以是任何类型，保证查找顺序。
- **`Set` (依赖桶)**：存储唯一的 `effect`。
  - *优势*：天然去重，防止同一 `effect` 因多次读取属性而重复触发。

##### 2. 核心拦截：Proxy & Reflect

- **`Proxy`**：负责拦截操作（get, set, has, deleteProperty 等）。
- **`Reflect`**：负责执行默认行为。
  - *关键参数 `receiver`*：在 `Reflect.get(target, key, receiver)` 中，它确保了当原始对象存在 `getter` 时，内部的 `this` 能够正确指向 **Proxy 对象** 而非原始对象，保证响应式不“断流”。

------

#### 四、 核心算法：虚拟 DOM 与 Diff

| **特性**     | **Vue 2 (双端 Diff)**          | **Vue 3 (快速 Diff)**                            |
| ------------ | ------------------------------ | ------------------------------------------------ |
| **比对策略** | 四个指针（新旧头尾）向中间靠拢 | 预处理相同头尾 + 中间部分 LIS 算法               |
| **DOM 移动** | 频繁移动，基于 Map 查找        | **LIS (最长递增子序列)** 确保最小化移动          |
| **静态优化** | 无（全量 Diff）                | **Block Tree**：直接跳过静态节点，仅比对动态节点 |

------

#### 五、 手写核心 `reactive` (简化版)

JavaScript

```javascript
const targetMap = new WeakMap();
let activeEffect = null;

function track(target, key) {
  if (!activeEffect) return;
  let depsMap = targetMap.get(target) || (targetMap.set(target, (depsMap = new Map())), depsMap);
  let dep = depsMap.get(key) || (depsMap.set(key, (dep = new Set())), dep);
  dep.add(activeEffect);
}

function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (depsMap?.get(key)) depsMap.get(key).forEach(effect => effect());
}

function reactive(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      const res = Reflect.get(target, key, receiver);
      track(target, key); // 收集依赖
      return typeof res === 'object' ? reactive(res) : res; // 惰性递归
    },
    set(target, key, value, receiver) {
      const oldVal = target[key];
      const res = Reflect.set(target, key, value, receiver);
      if (oldVal !== value) trigger(target, key); // 派发更新
      return res;
    }
  });
}
```

------

#### 六、 进阶 Tips：类型检测

使用 `Object.prototype.toString.call()` 可以精准识别集合类型：

- `[object Map]` / `[object Set]`
- 原理：利用了内建对象的 `Symbol.toStringTag` 属性。