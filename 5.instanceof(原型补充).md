#### 手写一个 myInstanceof

##### 代码逻辑：循环遍历原型链,沿着原型链往上面找直到找到原型或者找到null

```javascript
function myInstanceof(left, right) {
  // 1. 基础类型检查：instanceof 只能判断对象
  // 如果 left 是基础类型或者是 null，直接返回 false
  if (typeof left !== 'object' || left === null) return false;

  // 2. 获取构造函数的原型对象
  let targetPrototype = right.prototype;

  // 3. 获取实例的原型（第一层梯子）
  let proto = Object.getPrototypeOf(left);

  // 4. 循环向上攀爬原型链
  while (true) {
    // 如果找完了整个原型链（到达 Object.prototype.__proto__，即 null）还没找到
    if (proto === null) return false;

    // 如果当前原型等于构造函数的原型，说明匹配成功
    if (proto === targetPrototype) return true;

    // 否则，继续往上一层原型找
    proto = Object.getPrototypeOf(proto);
  }
}
```

------

##### 测试:`instanceof` 实际上是在做**路径搜索**

```javascript
class Parent {}
class Child extends Parent {}

const c = new Child();

// 测试 1：常规情况
console.log(myInstanceof(c, Child));  // true
console.log(myInstanceof(c, Parent)); // true

// 测试 2：如果你触发了“回马枪”，返回了一个完全无关的对象
function Stranger() {}
function Person() {
  return new Stranger(); // 掉包了！
}

const p = new Person();
console.log(myInstanceof(p, Person));   // false
console.log(myInstanceof(p, Stranger)); // true
```

##### 进阶冷知识：`Symbol.hasInstance`

在现代 JavaScript（ES6+）中，你其实可以**自定义** `instanceof` 的行为。如果你在一个类上定义了静态方法 `[Symbol.hasInstance]`，那么 `instanceof` 运算符会优先调用它，而不是去跑原型链搜索。

```javascript
class MyArray {
  static [Symbol.hasInstance](instance) {
    return Array.isArray(instance); // 只要是数组，就让它通过检测
  }
}

console.log([] instanceof MyArray); // true！尽管原型链上并没有 MyArray
```

这种设计体现了 JavaScript **“协议（Protocols）优于语法”** 的思想。