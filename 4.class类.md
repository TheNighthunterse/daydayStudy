##### 手写一个“单例模式”的类

> 核心思路：**无论调用多少次 `new`，永远返回第一次创建那个实例。**

1. 基础实现：利用静态属性，在类上挂一个静态属性 `instance` 来保存唯一的实例

   ```javascript
   class WindowManager {
     constructor(name) {
       // 1. 检查是否已经存在实例
       if (WindowManager.instance) {
         // 2. 如果存在，直接返回已有的实例，不再创建新对象
         return WindowManager.instance;
       }
   
       // 3. 如果不存在，则初始化新对象
       this.name = name;
       this.id = Math.random();
   
       // 4. 将当前实例保存到静态属性中
       WindowManager.instance = this;
       
       // 隐式返回 this (由于我们没有返回其他对象)
     }
   
     open() {
       console.log(`正在打开窗口: ${this.name} (ID: ${this.id})`);
     }
   }
   
   // --- 测试 ---
   const w1 = new WindowManager("主界面");
   const w2 = new WindowManager("配置界面");
   
   console.log(w1 === w2); // true
   w1.open(); // 正在打开窗口: 主界面 (ID: 0.123...)
   w2.open(); // 正在打开窗口: 主界面 (ID: 0.123...) —— 依然是第一个实例
   ```

2. 进阶版：闭包实现（更安全）

   方案1有一个缺点：`WindowManager.instance` 是公开的，外部代码可以手动把它删掉或修改。使用闭包可以将实例“隐藏”起来。

   ```javascript
   const SafeSingleton = (function() {
     let instance = null; // 闭包中的私有变量
   
     return class {
       constructor() {
         if (instance) {
           return instance;
         }
         this.initTime = new Date();
         instance = this;
       }
       
       getTime() {
         return this.initTime;
       }
     };
   })();
   
   const s1 = new SafeSingleton();
   const s2 = new SafeSingleton();
   console.log(s1 === s2); // true
   ```

   ------

   - **拦截机制**：当第二次 `new WindowManager()` 时，`constructor` 执行
   - **强制覆盖**：代码执行到 `return WindowManager.instance`
   - **丢弃新对象**：JS 引擎发现你返回了一个已有的**对象**，于是它直接把这个旧对象扔给 `w2`，而把原本为 `w2` 准备的那个空对象（`this`）当做垃圾回收掉

3. 疑问：为什么将`instance`设置为null之后仍然可以调用open

   ```javascript
    const w1 = new WindowManager('主界面');
   
     const w2 = new WindowManager('配置界面');
   
     w1.__proto__.constructor.instance = null;
   
     console.log((w1.__proto__, w1.__proto__.constructor)); // true
   
     w1.open(); // 正在打开窗口: 主界面 (ID: 0.123...)
   
     w2.open(); // 正在打开窗口: 主界面 (ID: 0.123...) 
   ```

   **结论：调用的时机晚了一步，在设置为null之前，`w1`和`w2`已经记录了之前的引用地址，所以仍能调用open，但是在设置null之后再创建一个`w3`再调用的话也会带有open，因为WindowManager里面判断instance为null就会重新设置**

   ```javascript
   w1.__proto__.constructor.instance = null; // 清空登记簿
   
   const w3 = new WindowManager('我是新来的'); 
   
   console.log(w1 === w3); // false! 
   w3.open(); // 正在打开窗口: 我是新来的 (ID: 0.987...)
   ```

4. 进阶探讨：如何防止别人手动置空？

   如果希望这个单例绝对安全，不让别人通过 `WindowManager.instance = null` 来搞破坏，可以使用前面说到的闭包，或者 `Object.defineProperty`：

   ```javascript
   class WindowManager {
     constructor() {
       if (WindowManager.instance) return WindowManager.instance;
       
       // ... 初始化逻辑 ...
   
       // 定义一个不可修改、不可删除的静态属性
       Object.defineProperty(WindowManager, 'instance', {
         value: this,
         writable: false,     // 不可写
         configurable: false  // 不可配置（不能删除）
       });
     }
   }
   ```

   现在，如果执行 `WindowManager.instance = null`，在严格模式下会报错，在非严格模式下则会静默失败。

##### 继承模式下的单例：子类会拿到父类实例吗？

​	会生效，但表现得可能和想象的不一样。

```javascript
class Parent {
  static instance = null;
  constructor() {
    if (Parent.instance) {
      return Parent.instance;
    }
    Parent.instance = this;
    this.type = 'Parent';
  }
}

class Child extends Parent {
  constructor() {
    super(); // 调用父类的 constructor
    this.subType = 'Child';
  }
}

const p = new Parent();
const c = new Child();

console.log(p === c); // true!
```

1. **`new Parent()` 执行**：创建了第一个对象，存入 `Parent.instance`。
2. **`new Child()` 执行**：
   - 进入 `Child` 的构造函数，调用 `super()`。
   - **关键点**：`super()` 实际上运行的是 `Parent` 的 `constructor` 代码。
   - 父类构造函数检查 `Parent.instance`，发现已经有值了，于是执行 `return Parent.instance`。
   - **回马枪生效**：此时 `super()` 返回的不再是新创建的子类实例，而是之前的那个 `Parent` 实例。
3. **子类属性丢失**：由于 `super()` 返回了一个现成的对象，`Child` 构造函数接下来的 `this.subType = 'Child'` 实际上是在给那个 **`Parent` 的老实例** 加属性。

会产生什么后果？

- **单例生效了**：`p` 和 `c` 指向同一个对象。
- **类型混乱**：`c` 看起来是一个 `Child`，但它实际上是 `Parent` 的实例。
- **属性污染**：如果你连续 `new` 不同的子类，它们都会去修改同一个父类单例对象的属性。

| **场景**         | **表现**                                   | **结论**                                       |
| ---------------- | ------------------------------------------ | ---------------------------------------------- |
| **闭包单例**     | 实例变量被隐藏，外部无法通过 `null` 破坏。 | **最推荐的生产实践。**                         |
| **子类继承单例** | `super()` 会强制返回父类的唯一实例。       | **单例跨越了类界限**。子类无法拥有独立的实例。 |

**疑问？：既然在class的constructor当中不管是否return都会返回对象，那是不是说明每一个继承的子类调用super()都会触发回马枪机制？**

从底层逻辑上讲，`super()` 确实一直在利用这种“机制”，但只有当你“显式返回”一个对象时，我们才称之为触发了“回马枪”（覆盖机制）

理解：**在继承当中，子类的super会调用父类的constructor并且此时constructor里面的this会指向调用constructor的对象也就是子类，所以在默认继承情况下父类的constructor会return this,这个this就是子类,然后再new子类时子类也会默认return this就是自己,但是如果父类显式的return了一个对象那么子类就会将this变成这个对象,所以在子类也没有显式return的情况下会return this也就是父类里面return的对象,而在这个案例当中第一次调用Parent时instance为null,所以设置Parent.instance = this;而第二次child调用时instance已经有值所以进入if判断并将这个instance也就是this给return出去导致child接收到了父类的this,最后在默认renturn this也就是Parent.instance,所以最后p===c为true**

###### 1. `this` 的初始身份（谁发起，**谁就是** this）

- 在 JavaScript 派生类（子类）的继承中，`this` 对象是由**子类**发起的 `new` 操作创建的。
- 执行 `super()` 时，父类的 `constructor` 并不是在操作它自己的对象，而是在“装修”这个由子类传上来的 `this`。此时父类内部的 `this` 原型链指向的是子类。

###### 2. 父类的“回马枪”机制（返回值覆盖）

- **正常情况**：父类 `constructor` 执行完毕后，如果没有显式 `return`，会默认返回传入的 `this`。
- **单例情况**：父类显式执行了 `return Parent.instance`。
- **结果**：如果 `instance` 已存在，父类会强行丢弃当前正在装修的 `this`（即子类实例），转而返回之前保存的老对象。

###### 3. 子类的“被迫接受”（super 的接收逻辑）

- 子类 `constructor` 执行 `super()` 的本质是：**接收父类构造函数的返回值，并将其确立为子类真正的 `this`**。
- 当父类返回了老实例时，子类原本的 `this` 就被彻底替换成了那个老实例。

###### 4. 最终的返回逻辑

- 在子类没有显式 `return` 的情况下，子类构造函数最后会默认执行 `return this`。
- 此时的 `this` 已经是经过 `super()` 替换后的老对象。因此，`new Child()` 最终拿到的结果就是 `Parent.instance`。

1. ------

   **第一次 `new Parent()`**：`instance` 为空，父类正常初始化并把 `this`（Parent 实例）存入 `instance`。

2. **第二次 `new Child()`**：调用 `super()` $\rightarrow$ 进入父类逻辑 $\rightarrow$ 发现 `instance` 已存在 $\rightarrow$ **父类 return 了那个 Parent 实例** $\rightarrow$ 子类的 `this` 变成了那个 Parent 实例 $\rightarrow$ 子类默认 return 这个 `this`。

3. **结果**：`p` 和 `c` 指向的是内存中同一个地址。

##### “this” 的身份是由最初的 `new` 命令决定的

​	如果先new Child再new Parent，两者仍然相等 但是两者都是Child而反过来则都是Parent

```javascript
class Parent {
  static instance = null;
  constructor() {
    if (Parent.instance) {
      return Parent.instance;
    }
    Parent.instance = this;
    this.type = 'Parent';
  }
}
class Child extends Parent {
  constructor() {
    super(); // 调用父类的 constructor
    this.subType = 'Child';
  }
}
const p = new Parent();
const c = new Child();

console.log(p === c); // true!
console.log(p); // Parent!
console.log(c); // Child!
```

第一个创建的实例“强占”了单例的席位，并且它会把自己的“户口（类信息）”永久保存在静态变量中

我们来拆解一下 `new Child()` 发生时的内存细节：

1. **启动**：执行 `new Child()`。此时 JS 引擎创建了一个原型指向 `Child.prototype` 的空对象。
2. **进入父类**：`Child` 的构造函数调用 `super()`，代码跑到了 `Parent` 的 `constructor` 里。
3. **身份确认**：**关键点来了！** 即使代码现在在 `Parent` 的花括号里运行，此时的 `this` 依然是步骤 1 中创建的那个 **`Child` 实例**。
4. **占位**：`Parent.instance = this;`。此时，`Parent.instance` 存入的是一个 `Child` 对象。
5. **后续调用**：当你接着执行 `new Parent()` 时，父类构造函数发现 `Parent.instance` 已经有值了，于是直接把那个 **`Child` 对象** 返还给了你。

> **核心结论：Identity Persistence（身份持久化）**

这个现象说明了三个深度知识点：

- **`this` 的唯一性**：在一个继承链中，无论有多少层父类，一次 `new` 操作只会产生**一个** `this` 对象。父类构造函数只是在“装修”这个由子类发起的 `this`。
- **单例的“盲目性”**：你的单例逻辑只检查“有没有对象”，而不检查“这个对象是什么类型”。它就像一个只有一张椅子的房间，谁先坐进去，后来的人（无论身份）拿到的都是那个人的名片。
- **静态属性是共享仓库**：因为 `Child` 继承自 `Parent`，所以 `Child.instance` 和 `Parent.instance` 实际上指向的是同一个内存空间。

> 如何修正？（让 Parent 永远是 Parent，Child 永远是 Child）

如果你希望实现“**分类单例**”，即父类有父类的单例，子类有子类的单例,可以动态地存储实例

```javascript
class Parent {
  static instances = new Map(); // 用 Map 存储，Key 是类本身
  constructor() {
    const ClassType = this.constructor; // 自动识别是 Parent 还是 Child
    if (Parent.instances.has(ClassType)) {
      return Parent.instances.get(ClassType);
    }

    Parent.instances.set(ClassType, this);
  }
}
class Child extends Parent {}
// 这样测试：
const p = new Parent();
const c = new Child();
console.log(p === c); // false，各自是各自的单例
console.log(new Child() === c); // true，子类也是单例
```

