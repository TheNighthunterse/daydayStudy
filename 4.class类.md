##### 手写一个“单例模式”的类

> 核心思路：**无论调用多少次 `new`，永远返回第一次创建那个实例。**

1. 基础实现：利用静态属性，在类上挂一个静态属性 `instance` 来保存唯一的实例

   ```javascript
   class WindowManager {
     constructor(name) {
       // 1. 检查是否已经存在实例
       if (WindowManager.instance) {
         // 2. 如果存在，直接返回已有的实例，不再创建新对象
         return WindowManager.instance;
       }
   
       // 3. 如果不存在，则初始化新对象
       this.name = name;
       this.id = Math.random();
   
       // 4. 将当前实例保存到静态属性中
       WindowManager.instance = this;
       
       // 隐式返回 this (由于我们没有返回其他对象)
     }
   
     open() {
       console.log(`正在打开窗口: ${this.name} (ID: ${this.id})`);
     }
   }
   
   // --- 测试 ---
   const w1 = new WindowManager("主界面");
   const w2 = new WindowManager("配置界面");
   
   console.log(w1 === w2); // true
   w1.open(); // 正在打开窗口: 主界面 (ID: 0.123...)
   w2.open(); // 正在打开窗口: 主界面 (ID: 0.123...) —— 依然是第一个实例
   ```

2. 进阶版：闭包实现（更安全）

   方案1有一个缺点：`WindowManager.instance` 是公开的，外部代码可以手动把它删掉或修改。使用闭包可以将实例“隐藏”起来。

   ```javascript
   const SafeSingleton = (function() {
     let instance = null; // 闭包中的私有变量
   
     return class {
       constructor() {
         if (instance) {
           return instance;
         }
         this.initTime = new Date();
         instance = this;
       }
       
       getTime() {
         return this.initTime;
       }
     };
   })();
   
   const s1 = new SafeSingleton();
   const s2 = new SafeSingleton();
   console.log(s1 === s2); // true
   ```

   ------

   - **拦截机制**：当第二次 `new WindowManager()` 时，`constructor` 执行
   - **强制覆盖**：代码执行到 `return WindowManager.instance`
   - **丢弃新对象**：JS 引擎发现你返回了一个已有的**对象**，于是它直接把这个旧对象扔给 `w2`，而把原本为 `w2` 准备的那个空对象（`this`）当做垃圾回收掉

3. 疑问：为什么将`instance`设置为null之后仍然可以调用open

   ```javascript
    const w1 = new WindowManager('主界面');
   
     const w2 = new WindowManager('配置界面');
   
     w1.__proto__.constructor.instance = null;
   
     console.log((w1.__proto__, w1.__proto__.constructor)); // true
   
     w1.open(); // 正在打开窗口: 主界面 (ID: 0.123...)
   
     w2.open(); // 正在打开窗口: 主界面 (ID: 0.123...) 
   ```

   **结论：调用的时机晚了一步，在设置为null之前，`w1`和`w2`已经记录了之前的引用地址，所以仍能调用open，但是在设置null之后再创建一个`w3`再调用的话也会带有open，因为WindowManager里面判断instance为null就会重新设置**

   ```javascript
   w1.__proto__.constructor.instance = null; // 清空登记簿
   
   const w3 = new WindowManager('我是新来的'); 
   
   console.log(w1 === w3); // false! 
   w3.open(); // 正在打开窗口: 我是新来的 (ID: 0.987...)
   ```

4. 进阶探讨：如何防止别人手动置空？

   如果希望这个单例绝对安全，不让别人通过 `WindowManager.instance = null` 来搞破坏，可以使用前面说到的闭包，或者 `Object.defineProperty`：

   ```javascript
   class WindowManager {
     constructor() {
       if (WindowManager.instance) return WindowManager.instance;
       
       // ... 初始化逻辑 ...
   
       // 定义一个不可修改、不可删除的静态属性
       Object.defineProperty(WindowManager, 'instance', {
         value: this,
         writable: false,     // 不可写
         configurable: false  // 不可配置（不能删除）
       });
     }
   }
   ```

   现在，如果执行 `WindowManager.instance = null`，在严格模式下会报错，在非严格模式下则会静默失败。

##### 继承模式下的单例：子类会拿到父类实例吗？

```javascript
class Parent {
  static instance = null;
  constructor() {
    if (Parent.instance) {
      return Parent.instance;
    }
    Parent.instance = this;
    this.type = 'Parent';
  }
}

class Child extends Parent {
  constructor() {
    super(); // 调用父类的 constructor
    this.subType = 'Child';
  }
}

const p = new Parent();
const c = new Child();

console.log(p === c); // true!
```

